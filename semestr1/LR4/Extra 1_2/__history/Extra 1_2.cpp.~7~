#pragma hdrstop
#pragma argsused

#ifdef _WIN32
#include <tchar.h>
#else
  typedef char _TCHAR;
  #define _tmain main
#endif

#include <stdio.h>
//Задана  матрицы  А  размерности  N*M  (N,M<=100).  Элементы  матрицы  целые  знаковые  числа.
//Построить динамическую  матрицу В, строки которой будут состоять только из  всех повторяющихся элементов соответствующей строки матрицы А.
//В  конце строк   нули не добавлять, а  сделать строки переменной длины. 
#include <conio.h>
#include <iostream>
#include <ctime>
using namespace std;
int _tmain() {

	srand(time(0));
	int n, m;
	cout << "Enter number of rows of the array: ";
	cin >> n;
	cout << "Enter number of columns of the array: ";
	cin >> m;

	int** arr = new int* [n];
	for (int i = 0; i < n; i++)
	{
		arr[i] = new int[m];
	}
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			arr[i][j] = rand() % 10 - 5;
			cout << arr[i][j] << '\t';			//создание исходного массива
		}
		cout << endl << endl;
	}
	cout << endl << endl;
	int** newarr = new int* [n];

	int* length = new int[n];		//массив хранящий длины строк
	for (int i = 0; i < n; i++)
	{
		int* rep = new int[m / 2];			//массив содержащий повторы
		for (int k = 0; k < m / 2; k++)
		{
			rep[k] = INT_MAX;				//заполнение массива
		}

		int len = 0;
		for (int j = 0; j < m; j++)
		{
			for (int z = j + 1; z < m; z++)
			{
				if (arr[i][z] == arr[i][j] && arr[i][z] != INT_MAX) //проверяем является ли элемент повторяющимся
				{
					rep[len++] = arr[i][z];				//заполнение массива повторов
					if (len > 1) {		//
						if (rep[len - 1] == rep[len - 2])	//проверяем есть ли у нас повторы в новом массиве
						{
							rep[len - 1] = INT_MAX;			//если есть повтор, убираем его
							len--;
						}
					}
					arr[i][z] = INT_MAX;
				}
			}
		}

		if (len)
		{
			length[i] = len;	//элементу массива, хранящего длины строк число элементов в данной строке
			newarr[i] = new int[len];	//создаем в новом массиве строку данного размера
		}
		/*else
		{
			length[i] = 0;
			arr[i] = NULL;
		}*/


		for (int k = 0; k < len; k++)
		{
			newarr[i][k] = rep[k];	//заполняем ячейку нового массива повторяющимся элементом
		}
		delete[]rep;
	}

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < length[i]; j++)
		{
			cout << newarr[i][j] << '\t';
		}
		cout << endl << endl;
	}

	for (int i = 0; i < n; i++) {
		delete[] newarr[i];
		delete[] arr[i];
	}
	delete[] newarr;
	delete[] arr;

	getch();
	return 0;
}

